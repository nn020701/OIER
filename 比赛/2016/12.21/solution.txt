T1:
使用一个栈模拟一下,读入一个S就压入栈,读入一个R就把最顶端的2个S弹栈.
T2:
对序列排序,最后选的肯定连续的m个数字(因为你想要让波动程度最小).
因此枚举区间的左端点,前缀和计算区间的方差即可.
T3:
一定存在一对(l,r)使得第l个数到第r个数的和是n的倍数.
证明:
对这个序列在 mod n 下做前缀和,得到n+1个数字s[0],s[1]...,s[n],s[0]=0.
因为是mod n下,因此最多只有n种数字,所以这n+1个数字里一定有一对x,y(x<y)使得s[x]=s[y].
我们令l=x+1,r=y即可.
T4:
注意到曼哈顿距离只有2m+2种,因此当n*(n-1)/2>2m+2时答案一定是YES.
否则我们暴力一下就好了.
T5:
注意到你的走法等效于辗转相减.
因此(x,y)可以走到(n,m)的条件就是gcd(x,y)=gcd(n,m)